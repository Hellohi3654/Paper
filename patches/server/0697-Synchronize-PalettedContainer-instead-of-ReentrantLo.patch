From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 29 May 2020 20:29:02 -0400
Subject: [PATCH] Synchronize PalettedContainer instead of ReentrantLock

Mojang has flaws in their logic about chunks being concurrently
wrote to. So we constantly see crashes around multiple threads writing.

Additionally, java has optimized synchronization so well that its
in many times faster than trying to manage read wrote locks for low
contention situations.

And this is extremely a low contention situation.

diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 82a4b7969e36940cb694bd999b8c03f9c66a71dc..05d5a77c439b177dc12b8b1ebd4181a5446c0f31 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -37,16 +37,18 @@ public class PalettedContainer<T> implements PaletteResize<T> {
     private final DebugBuffer<Pair<Thread, StackTraceElement[]>> traces = null;
 
     public void acquire() {
+        /* // Paper start - disable this - use proper synchronization
         if (this.traces != null) {
             Thread thread = Thread.currentThread();
             this.traces.push(Pair.of(thread, thread.getStackTrace()));
         }
 
         ThreadingDetector.checkAndLock(this.lock, this.traces, "PalettedContainer");
+        */ // Paper end
     }
 
     public void release() {
-        this.lock.release();
+        //this.lock.release(); // Paper - disable this
     }
 
     // Paper start - Anti-Xray - Add predefined objects
@@ -134,7 +136,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return this.palette.idFor(objectAdded);
     }
 
-    public T getAndSet(int x, int y, int z, T value) {
+    public synchronized T getAndSet(int x, int y, int z, T value) { // Paper - synchronize
         Object var6;
         try {
             this.acquire();
@@ -158,7 +160,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return (T)(object == null ? this.defaultValue : object);
     }
 
-    public void set(int i, int j, int k, T object) {
+    public synchronized void set(int i, int j, int k, T object) { // Paper - synchronize
         try {
             this.acquire();
             this.set(getIndex(i, j, k), object);
@@ -182,7 +184,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return (T)(object == null ? this.defaultValue : object);
     }
 
-    public void read(FriendlyByteBuf buf) {
+    public synchronized void read(FriendlyByteBuf buf) { // Paper - synchronize
         try {
             this.acquire();
             int i = buf.readByte();
@@ -203,7 +205,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
     @Deprecated public void write(FriendlyByteBuf buf) {
         write(buf, null, 0);
     }
-    public void write(FriendlyByteBuf buf, com.destroystokyo.paper.antixray.ChunkPacketInfo<T> chunkPacketInfo, int chunkSectionIndex) {
+    public synchronized void write(FriendlyByteBuf buf, com.destroystokyo.paper.antixray.ChunkPacketInfo<T> chunkPacketInfo, int chunkSectionIndex) { // Paper - synchronize
         // Paper end
         try {
             this.acquire();
@@ -224,7 +226,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
 
     }
 
-    public void read(ListTag paletteNbt, long[] data) {
+    public synchronized void read(ListTag paletteNbt, long[] data) { // Paper - synchronize
         try {
             this.acquire();
             // Paper - Anti-Xray - TODO: Should this.predefinedObjects.length just be added here (faster) or should the contents be compared to calculate the size (less RAM)?
@@ -259,7 +261,7 @@ public class PalettedContainer<T> implements PaletteResize<T> {
 
     }
 
-    public void write(CompoundTag nbt, String paletteKey, String dataKey) {
+    public synchronized void write(CompoundTag nbt, String paletteKey, String dataKey) { // Paper - synchronize
         try {
             this.acquire();
             HashMapPalette<T> hashMapPalette = new HashMapPalette<>(this.registry, this.bits, this.dummyPaletteResize, this.reader, this.writer);
